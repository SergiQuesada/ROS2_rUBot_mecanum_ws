<!DOCTYPE html>
<html lang="ca">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ROS Multi-Robot Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/roslib@1/build/roslib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
  <style>
    :root{
      --gap: 20px;
      --card-bg: #fff;
      --card-bd: #ccc;
      --page-bg: #585858; /* una mica m√©s clar per veure b√© el mapa */
    }

    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--page-bg);
      color: #000;
    }

    /* Layout principal: 2 panells (A i B) en dues columnes */
    .app {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 24px;
    }
    @media (max-width: 1100px){
      .app { grid-template-columns: 1fr; }
    }

    /* Panell individual amb la mateixa estructura del teu index: 
       fila 1 ‚Üí c√†mera (esq), panell dret (joystick, œâz, velocitats)
       fila 2 ‚Üí mapa (esq), posici√≥/orientaci√≥ (dreta) */
    .panel {
      background: #dedede;
      border-radius: 10px;
      padding: 14px;
      box-shadow: 0 2px 10px #0004;
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-areas:
        "header header"
        "camera right"
        "map    pos";
      gap: var(--gap);
      align-items: center;
      justify-items: center;
    }

    /* header (Robot + Connect) */
    .header {
      grid-area: header;
      width: 100%;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
      justify-content: flex-start;
    }
    .header h2 { color: #fff; font-size: 1.05rem; margin: 0 8px 0 0; }
    .header label { color: #fff; }
    .header input[type="number"]{
      width: 70px;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #bbb;
      background: #fff;
    }
    .header button{
      padding: 8px 14px;
      border-radius: 6px;
      border: 1px solid #bbb;
      background: #f5f5f5;
      cursor: pointer;
    }
    .header button:hover { filter: brightness(0.97); }
    .header button.connected {
      background: #2ecc71;
      border-color: #2ecc71;
      color: #fff;
    }

    /* C√†mera */
    .camera { grid-area: camera; }
    .image-view {
      width: 360px;
      height: 270px;
      background-color: #000;
      border-radius: 5px;
      border: 1px solid var(--card-bd);
      object-fit: cover;
      display: block;
    }

    /* Panell dret: llegenda ‚Üí joystick ‚Üí slider ‚Üí velocitats (apilat i centrat) */
    .right-panel { 
      grid-area: right;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      width: 100%;
    }
    .joy-legend {
      font-size: 1rem;
      font-weight: 700;
      color: #eee;
      text-align: center;
      margin-top: 0;
    }
    .joystick-container {
      width: 200px;
      height: 200px;
      background-color: #ddd;
      border-radius: 50%;
      position: relative;
      overflow: hidden;
      touch-action: none; /* evita scroll/zoom accidental al m√≤bil */
    }
    .omega-wrap {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      color: #eee;
      font-size: 0.95rem;
      width: 100%;
    }
    .omega-wrap input[type="range"] { width: 180px; }
    .joy-vel {
      font-size: 0.9rem;
      color: #ddd;
      text-align: center;
    }

    /* Mapa i posici√≥/orientaci√≥ */
    .map-display { 
      grid-area: map;
      width: min(280px, 100%);
      background-color: var(--card-bg, #fff);
      border: 1px solid var(--card-bd, #ccc);
      border-radius: 5px;
      padding: 10px;
      color: #111;
    }
    .map-image {
      width: 100%;
      height: auto;
      border: 1px solid var(--card-bd);
      border-radius: 5px;
      display: block;
      background: #fafafa;
    }

    .position-display { 
      grid-area: pos;
      width: 200px;
      background-color: var(--card-bg, #fff);
      border: 1px solid var(--card-bd, #ccc);
      border-radius: 5px;
      padding: 10px;
      color: #111;
    }

    @media (max-width: 900px) {
      .panel {
        grid-template-columns: 1fr;
        grid-template-areas:
          "header"
          "camera"
          "right"
          "map"
          "pos";
      }
      .joystick-container { width: 160px; height: 160px; }
      .image-view { width: 100%; max-width: 520px; height: auto; }
      .map-display, .position-display { width: 100%; max-width: 520px; }
    }
  </style>
</head>

<body>
  <div class="app">
    <!-- ============= PANEL ROBOT A ============= -->
    <section class="panel" id="panelA">
      <div class="header">
        <h2>Robot A</h2>
        <label for="robotNumberA">Robot:</label>
        <input id="robotNumberA" type="number" min="1" max="9" value="1" title="Robot number"/>
        <button id="connectBtnA">Connect</button>
      </div>

      <div class="camera">
        <img class="image-view" id="cameraA" alt="Camera A" />
      </div>

      <aside class="right-panel">
        <div class="joy-legend">Joystick</div>
        <div class="joystick-container" id="joystickA"></div>

        <div class="omega-wrap">
          <label for="omegaSliderA">œâùìè:</label>
          <input id="omegaSliderA" type="range" min="-1" max="1" step="0.01" value="0" />
          <span id="omegaValA">0.00</span> rad/s
        </div>

        <div class="joy-vel">
          v‚Çì: <span id="vxA">0.00</span> m/s ¬∑ v·µß: <span id="vyA">0.00</span> m/s
        </div>
      </aside>

      <div class="map-display">
        <h3>Map</h3>
        <canvas id="mapA" class="map-image" width="200" height="200"></canvas>
      </div>

      <div class="position-display">
        <h3>Position & Orientation</h3>
        <p>X (m): <span id="xA">0</span></p>
        <p>Y (m): <span id="yA">0</span></p>
        <p>&Theta; (¬∫): <span id="yawA">0</span></p>
      </div>
    </section>

    <!-- ============= PANEL ROBOT B ============= -->
    <section class="panel" id="panelB">
      <div class="header">
        <h2>Robot B</h2>
        <label for="robotNumberB">Robot:</label>
        <input id="robotNumberB" type="number" min="1" max="9" value="2" title="Robot number"/>
        <button id="connectBtnB">Connect</button>
      </div>

      <div class="camera">
        <img class="image-view" id="cameraB" alt="Camera B" />
      </div>

      <aside class="right-panel">
        <div class="joy-legend">Joystick</div>
        <div class="joystick-container" id="joystickB"></div>

        <div class="omega-wrap">
          <label for="omegaSliderB">œâùìè:</label>
          <input id="omegaSliderB" type="range" min="-1" max="1" step="0.01" value="0" />
          <span id="omegaValB">0.00</span> rad/s
        </div>

        <div class="joy-vel">
          v‚Çì: <span id="vxB">0.00</span> m/s ¬∑ v·µß: <span id="vyB">0.00</span> m/s
        </div>
      </aside>

      <div class="map-display">
        <h3>Map</h3>
        <canvas id="mapB" class="map-image" width="200" height="200"></canvas>
      </div>

      <div class="position-display">
        <h3>Position & Orientation</h3>
        <p>X (m): <span id="xB">0</span></p>
        <p>Y (m): <span id="yB">0</span></p>
        <p>&Theta; (¬∫): <span id="yawB">0</span></p>
      </div>
    </section>
  </div>

  <script>
    /* ===== Config global (mateixa que el teu index actual) ===== */
    const MAP_RESOLUTION = 0.01;     // m/p√≠xel
    const ROBOT_RADIUS   = 5;        // p√≠xels
    const SPEED_VECTOR_SCALE = 100;  // p√≠xels per (m/s): m√©s llarg per veure-ho clar

    const maxSpeed = 0.3;   // m/s (Vx, Vy) amb clamp vectorial
    const maxTurn  = 0.4;   // rad/s (œâz)
    const distanceFactor = 75; // ~ radi joystick

    function quaternionToYaw(q) {
      const siny_cosp = 2 * (q.w * q.z + q.x * q.y);
      const cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
      return Math.atan2(siny_cosp, cosy_cosp); // radians
    }

    function getRosbridgeAddressFallback(){
      const currentUrl = window.location.href;
      const rosbridgeUrl = currentUrl.replace(/\/webpage\/?$/, '/rosbridge/');
      return rosbridgeUrl.replace(/^http/, 'ws').replace(/^https/, 'wss');
    }

    function computeRosbridge(host, robotNum){
      const scheme = location.protocol === 'https:' ? 'wss' : 'ws';
      if (host.startsWith("192.168.1.")) {
        const lastOctet = robotNum * 10 + 4; // x4 ‚Üí 1‚Üí14, 2‚Üí24, ‚Ä¶
        return `${scheme}://192.168.1.${lastOctet}:9090`;
      }
      return getRosbridgeAddressFallback();
    }

    function clampVector(x,y,maxMag){
      const m = Math.hypot(x,y);
      if (m > maxMag && m > 0) {
        const k = maxMag / m;
        return [x*k, y*k];
      }
      return [x,y];
    }

    /* ===== Classe Panel (replica el teu flux per a cada robot) ===== */
    class RobotPanel {
      constructor(prefix){
        // prefix = 'A' | 'B'
        this.prefix = prefix;

        // UI refs
        this.robotInput   = document.getElementById(`robotNumber${prefix}`);
        this.connectBtn   = document.getElementById(`connectBtn${prefix}`);
        this.cameraImg    = document.getElementById(`camera${prefix}`);
        this.canvas       = document.getElementById(`map${prefix}`);
        this.ctx          = this.canvas.getContext('2d');

        this.omegaSlider  = document.getElementById(`omegaSlider${prefix}`);
        this.omegaVal     = document.getElementById(`omegaVal${prefix}`);
        this.vxEl         = document.getElementById(`vx${prefix}`);
        this.vyEl         = document.getElementById(`vy${prefix}`);
        this.xEl          = document.getElementById(`x${prefix}`);
        this.yEl          = document.getElementById(`y${prefix}`);
        this.yawEl        = document.getElementById(`yaw${prefix}`);

        this.joyZone      = document.getElementById(`joystick${prefix}`);

        // ROS state
        this.ros = null;
        this.cmdVelTopic = null;

        // Control state
        this.currentLinearX = 0;
        this.currentLinearY = 0;
        this.currentAngularZ = 0;

        // Map image per panel
        this.mapImage = new Image();
        this.mapImage.src = 'maps/map.png';
        this.mapImage.onload = () => this.resizeMapCanvas();

        this.bindUI();
        this.setupLoop();
      }

      bindUI(){
        // Connect
        this.connectBtn.addEventListener('click', () => this.connect());

        // Slider œâz
        this.omegaSlider.addEventListener('input', () => {
          this.currentAngularZ = parseFloat(this.omegaSlider.value) * maxTurn;
          this.omegaVal.textContent = this.currentAngularZ.toFixed(2);
        });

        // Joystick (omni: Vx + Vy)
        const j = nipplejs.create({
          zone: this.joyZone,
          mode: 'static',
          position: { left: '50%', top: '50%' },
          color: 'red',
          size: 150
        });
        j.on('move', (evt, data) => {
          const ratio = Math.min(data.distance / distanceFactor, 1.0);
          let vx = Math.sin(data.angle.radian) * maxSpeed * ratio;
          let vy = -Math.cos(data.angle.radian) * maxSpeed * ratio;
          [vx, vy] = clampVector(vx, vy, maxSpeed);
          this.currentLinearX = vx;
          this.currentLinearY = vy;
          this.vxEl.textContent = vx.toFixed(2);
          this.vyEl.textContent = vy.toFixed(2);
        });
        j.on('end', () => {
          this.currentLinearX = 0;
          this.currentLinearY = 0;
          this.vxEl.textContent = '0.00';
          this.vyEl.textContent = '0.00';
        });

        // Resize DPR
        window.addEventListener('resize', () => this.resizeMapCanvas());

        // Valida robot 1..9
        this.robotInput.addEventListener('change', (e) => {
          let v = parseInt(e.target.value) || 1;
          if (v < 1) v = 1;
          if (v > 9) v = 9;
          e.target.value = v;
        });
      }

      setupLoop(){
        // Publicaci√≥ /cmd_vel ~20Hz
        setInterval(() => this.publishTwist(), 50);
      }

      connect(){
        if (this.ros && this.ros.isConnected) return;

        const robotNum = parseInt(this.robotInput.value) || 1;
        const host = window.location.hostname;
        const url = computeRosbridge(host, robotNum);

        this.connectBtn.setAttribute('disabled', 'disabled');

        this.ros = new ROSLIB.Ros({ url });

        this.ros.on('connection', () => {
          this.connectBtn.classList.add('connected');
          this.connectBtn.removeAttribute('disabled');
          this.ros.isConnected = true;
          this.setupTopics();
          console.log(`[${this.prefix}] Connected:`, url);
        });
        this.ros.on('error', (err) => {
          console.error(`[${this.prefix}] Error:`, err);
          this.connectBtn.classList.remove('connected');
          this.connectBtn.removeAttribute('disabled');
          this.ros.isConnected = false;
        });
        this.ros.on('close', () => {
          console.warn(`[${this.prefix}] Closed`);
          this.connectBtn.classList.remove('connected');
          this.connectBtn.removeAttribute('disabled');
          this.ros.isConnected = false;
        });
      }

      setupTopics(){
        // /cmd_vel
        this.cmdVelTopic = new ROSLIB.Topic({
          ros: this.ros,
          name: '/cmd_vel',
          messageType: 'geometry_msgs/Twist'
        });

        // c√†mera
        const imageTopic = new ROSLIB.Topic({
          ros: this.ros,
          name: '/camera1/image_raw/compressed',
          messageType: 'sensor_msgs/CompressedImage'
        });
        imageTopic.subscribe((message) => {
          this.cameraImg.src = "data:image/jpeg;base64," + message.data;
        });

        // odometria -> dibuix al mapa + textos
        const odomTopic = new ROSLIB.Topic({
          ros: this.ros,
          name: '/odom',
          messageType: 'nav_msgs/Odometry'
        });
        odomTopic.subscribe((message) => {
          const p = message.pose.pose.position;
          const q = message.pose.pose.orientation;
          const yaw = quaternionToYaw(q);
          const yawDeg = yaw * 180 / Math.PI;

          this.xEl.textContent = p.x.toFixed(2);
          this.yEl.textContent = p.y.toFixed(2);
          this.yawEl.textContent = yawDeg.toFixed(1);

          // Velocitat global per vector de dibuix
          const vx_r = message.twist.twist.linear.x;
          const vy_r = message.twist.twist.linear.y;
          const vx_g = vx_r * Math.cos(yaw) - vy_r * Math.sin(yaw);
          const vy_g = vx_r * Math.sin(yaw) + vy_r * Math.cos(yaw);

          this.drawRobotState(p.x, p.y, vx_g, vy_g, yaw);
        });
      }

      publishTwist(){
        if (!this.cmdVelTopic) return;
        // clamp vectorial
        let vx = this.currentLinearX;
        let vy = this.currentLinearY;
        [vx, vy] = clampVector(vx, vy, maxSpeed);

        const twist = new ROSLIB.Message({
          linear:  { x: vx, y: vy, z: 0 },
          angular: { x: 0, y: 0, z: this.currentAngularZ }
        });
        this.cmdVelTopic.publish(twist);
      }

      resizeMapCanvas(){
        const canvas = this.canvas;
        if (!canvas) return;
        const dpr = window.devicePixelRatio || 1;
        const cssW = canvas.clientWidth;
        const cssH = canvas.clientHeight;
        canvas.width  = Math.round(cssW * dpr);
        canvas.height = Math.round(cssH * dpr);
        this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        // redibuixa si tenim imatge
        this.ctx.clearRect(0,0,cssW,cssH);
        if (this.mapImage.complete) {
          this.ctx.drawImage(this.mapImage, 0, 0, cssW, cssH);
        }
      }

      drawRobotState(robotX, robotY, velX, velY, yaw){
        const canvas = this.canvas;
        const ctx = this.ctx;
        const W = canvas.clientWidth;
        const H = canvas.clientHeight;

        ctx.clearRect(0, 0, W, H);
        if (this.mapImage.complete) {
          ctx.drawImage(this.mapImage, 0, 0, W, H);
        }

        // (0,0) al centre
        const pixelX = robotX / MAP_RESOLUTION + W / 2;
        const pixelY = H / 2 - robotY / MAP_RESOLUTION;

        // Robot
        ctx.beginPath();
        ctx.arc(pixelX, pixelY, ROBOT_RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = 'green';
        ctx.fill();
        ctx.strokeStyle = 'black';
        ctx.stroke();

        // Orientaci√≥
        const orientationLength = ROBOT_RADIUS * 1.5;
        const endYawX = pixelX + Math.cos(yaw) * orientationLength;
        const endYawY = pixelY - Math.sin(yaw) * orientationLength;
        ctx.beginPath();
        ctx.moveTo(pixelX, pixelY);
        ctx.lineTo(endYawX, endYawY);
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'blue';
        ctx.stroke();

        // Vector velocitat global
        const speed = Math.hypot(velX, velY);
        if (speed > 0.01) {
          const movementAngle = Math.atan2(velY, velX);
          const vectorLength = speed * SPEED_VECTOR_SCALE;
          const endX = pixelX + Math.cos(movementAngle) * vectorLength;
          const endY = pixelY - Math.sin(movementAngle) * vectorLength;

          ctx.beginPath();
          ctx.moveTo(pixelX, pixelY);
          ctx.lineTo(endX, endY);
          ctx.lineWidth = 2;
          ctx.strokeStyle = 'red';
          ctx.stroke();

          // Fletxa
          ctx.fillStyle = 'red';
          ctx.save();
          ctx.translate(endX, endY);
          ctx.rotate(-movementAngle);
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(-10, 5);
          ctx.lineTo(-10, -5);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
      }
    }

    // Inst√†ncies: A i B
    const panelA = new RobotPanel('A');
    const panelB = new RobotPanel('B');

    // (opcional) Dedu√Øm el robot per defecte segons IP que serveix la p√†gina
    window.addEventListener('DOMContentLoaded', () => {
      const host = window.location.hostname; // "192.168.1.14"
      const m = host.match(/^192\.168\.1\.(\d+)$/);
      if (m) {
        const last = parseInt(m[1],10);
        const guess = Math.floor((last - 4)/10); // 14‚Üí1, 24‚Üí2, ...
        if (guess >= 1 && guess <= 9) {
          document.getElementById('robotNumberA').value = String(guess);
        }
      }
    });
  </script>
</body>
</html>
